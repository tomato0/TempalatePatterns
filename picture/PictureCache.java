package design.wang.com.designpatterns.picture;

import android.graphics.Bitmap;

import java.lang.ref.SoftReference;
import java.util.HashMap;
import java.util.Map;

/**
 * 知其然，而后知其所以然
 * 倔强小指，成名在望
 * 作者： Tomato
 * on 2018/4/21 0021.
 * design.wang.com.designpatterns.picture
 * 功能、作用：
 */

public class PictureCache {
    /*
    * 图片的三级缓存：
    * 网络缓存
    * 内存缓存
    * 文件缓存
    *
    * 思路：获取服务器端图片的流程
    * 获取图片------》查看内存中是否存在
    *               ------》存在，直接使用
    *               ------》不存在，查找是否以文件的形式存储在存储器上
    *                       -------》文件中存在，直接获取使用，同时将图片存储到内存中
    *                       -------》不存在，网络请求获取远程服务器端图片，同时将获取到的图片同时存储在内存中和
    *                               以文件形式存储在存储器上
    */

    /*
    * 内存缓存的实现：
    *
    * Android四种对象引用方式
    * 1、强引用：如果一个对象具有强引用，那么垃圾回收绝不会回收它。当内存空间不足时，java虚拟机宁愿抛出outOfMemoryError，
    * 使程序意外终止，也不会随意回收具有强引用的对象。平常对对象的引用默认就是强引用(ClassA a = new ClassA())
    * 2、软引用：如果一个对象具有软引用，则内存空间足够，垃圾回收就不会回收它，如果内存空间不足了，就会回收这些对象。
    * 只要垃圾回收没有回收它，该对象就可以被使用。软引用来实现内存敏感的高速缓存。
    * 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用的对象被垃圾回收器回收，那么Java虚拟机就会把这个
    * 软引用加入到与之关联的队列中。
    * 3、弱引用：只具有弱引用的对象具有更短暂的生命周期，在垃圾回收器扫描到具有弱引用的对象，不管内存空间是否足够，都会将
    * 其回收。不过，垃圾回收器是一个优先级很低的线程，不一定能马上发现这些只具有弱引用的对象。
    * 4、虚引用：顾明思议，就是形同虚设，如果一个对象仅持有虚引用，那么它就和没有引用一样，在任何时候都可能会被垃圾
    * 回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列联合使用。
    *
    * 从Android 2. 3开始，垃圾回收器会更倾向于回收持有软引用或弱引用的对象，这让软引用和弱引用变得不再可靠
    * Map+软引用
    *
    * 新的缓存方式
    * 内存缓存LruCache
    * 最近最少使用原则，当内存不足时，优先回收最近时间内使用最少的资源
    * LruCache使用LinkedHashMap<K,V>来缓存对象，cache通过一个强引用来访问内容，每次当一个item被访问到是，这个item
    * 就会被移动到队列的队首。当一个item被添加到一个已经满了的队列时，这个队列的队尾的item就会被移除。从而实现了
    * 最近最少使用的算法。
    *
    */

    //软引用缓存Bitmap
    private Map<String, SoftReference<Bitmap>> mSoftCache = new HashMap<>();
}
